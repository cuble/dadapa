1. To ignore generated files added to the git repo
  - add files you want to ignore into .gitignore in the repo

2. To do automatic compile after commit
  - To detect if src file changed

3. To check the change in GUI
  - gitk [file]

4. There are three level git config values: /etc/gitconfig, ~/.gitconfig, ./.git/config

5. git log --pretty=format:"options", options as following:
    %H  Commit hash
    %h  Abbreviated commit hash
    %T  Tree hash
    %t  Abbreviated tree hash
    %P  Parent hashes
    %p  Abbreviated parent hashes
    %an Author name
    %ae Author e-mail
    %ad Author date (format respects the –date= option)
    %ar Author date, relative
    %cn Committer name
    %ce Committer email
    %cd Committer date
    %cr Committer date, relative
    %s  Subject
  filter options for git log:
    --since, --after, --util, --before,  --author, --committer, --grep(used to grep commit message), -(n) (show only last n commits)
	--all-match, this option is needed in some condition to make filter by all given conditions
	file name or path can be given to filter logs that contain the selected files change information. '--' is used to split files or path from options
	example: git log --since=2012-10-1 --before=2013-10-1 -- README
	
6. git remote:
  - git remote -v
  - git remote add [name] [url]
  - git remote show [name], show branch information of remote and related configuration locally
  - git remote rename [orgName] [newName], git remote rm [name]
  
7. git tag
  - git tag -l 'v1.4.2.*', used to list all the tags start with v1.4.2.
  - git tag -a [tagName] -m [message], to add a annotated tag. git tag -a [tagName] -m [message] [commitChecksum] can be used to tag a old commit.
  - git tag -s [tagName] -m [message], to add a signed tag, which can be verified by 'git tag -v [tagName]'
  - git tag [tagName], create a lightweight tag which create a file referred to the commit checksum.
  - git push origin [tagName], to push the tag to origin server. git push origin --tags to push all tags to origin server.
  
8. tips:
  - make auto completion work for git: source git-completion.bash. 'git-completion.bash' located in git source code's contrib/completion. add the command into .bashrc to make it auto configured. Or copy it to /etc/bash_completion.d/ to make it auto configured for all uses.
  - git config --global alias.visual '!gitk', to make 'git visual' load external command 'gitk'.

9. work with branch
  - git checkout -b issuexx, create a new branch named issuexx from HEAD and checkout it
    - git checkout -b issuexx origin/issuexx, to create local issuexx branch base on remote issuexx and check it out
	  - git checkout --track origin/issuexx, the same as up command
  - git branch issueyy, create a branch named issueyy from HEAD
    - git branch, show all branchs 
	- git branch -v, show HEAD information of all branchs
	- git branch --merged(--no-merged), to filter branches concerning whether the content of the branch merged to current branch(master)
  - git merge issueyy, merge branch issueyy into current HEAD
  - git mergetool, to laugch visule merge tool when conflict found after merge
  - git branch -d [branchName], to delete a branch
    - git branch -D [branchName], to force delete a branch, which not one of the ancestor of the HEAD(not merged yet)
  - git push [remoteName] [branchName], to push local branch to remote
    - git push [remoteName] [localBranch]:[remoteBranch], to push local branch to remote and reset name
    - git push [remoteName] :[branchName], to remove a remote branch
  - git rebase [baseBranch]: merge current branch to base branch in rebase manner
    - git rebase [baseBranch] [topicBranch]: merge topic branch to base branch in rebase manner
    - git rebase --onto [targetBranch] [baseBranch] [topicBranch]: merge topic branch's content, which not in the base branch, to target branch in rebase manner

10. Create git server
  - SSH protocal: all you need is a SSH server and a bare repository, which users can access
    - Authenticate with file access need to setup accounts on SSH server one by one
	- Authenticate with SSH access
	  - create user 'git' on SSH server, and create file ~/.ssh/authorized_keys
	  - collecting pub keys of users, and add them into the authorized_keys, cat id_rsa.userxx.pub >> ~/.ssh/authorized_keys
	  - userxx do: git remote add origin git@gitserver:/path/to/project.git, check if git works
	  - disable shell of user 'git': change user's shell in /etc/passwd from '/bin/bash' to '/usr/bin/git-shell', test it by: 'ssh git@gitserver'
  - HTTP protocal: 
    - Apache Server
	- gitweb
  - Git Server Management: gitosis, gitolite
  - Git Protocal:
  

11. Work modes
  - Peer group
    - git clone [remote] [localdir], work on master
        - git commit -am [msg]
        - git push origin master, do following thing if be rejected
        - git fetch origin
        - git merge origin/master, then push

    - git branch issuexx, work on issuexx
        - git fetch origin,
        - git log --no-merges origin/master ^issuexx, check others' change
        - git checkout master, git merge issuexx, git merge origin/master, then push

  - Peer groups with dedicate integrate manager
    - git checkout -b FeatureA, work on FeatureA
        - you can switch to FeatureA if you have worked on other branch, git checkout FeatureA
        - git fetch origin
        - git merge origin/FeatureA, OR "git merge origin/FeatrueApp" in case remote branch is FeatrueApp
        - git push origin FeatureA, OR "git push origin FeatureA:FeatureApp" in case remote branch is FeatureApp
        - After FeatureA ready, the integrater manager will do following things:
            - git fetch origin
            - git merge origin/FeatureA, maybe also "git merge origin/FeatureB" in case other features ready too
            - git push origin master
  - Commit though integrate manager by git commits
    - clone the project and work on local FeatureA branch, fork it remotely
        - git add remote myfork (url)
        - git push myfork FeatureA
        - git request-pull origin/master myfork, email the maintainer the output of the command
        - git checkout -b FeatrueB origin/master, then work on another feature
        - if the integrate manager reject your contribution because your commit need to be merged to the latest master branck
            - git checkout FeatureA
            - git rebase origin/master, and resolve the conflicts
            - git push -f myfork FeatureA
        - if the integrate manager reject your contribution because he/she has some comments on your solution, you can rework it as following
            - git checkout FeatureBv2 origin/master
            - git merge --no-commit --squash FeatureB, "--squash" used to digger the change, and "--no-commit" make git not to commit automatically. 
            - work, and git commit
            - git push myfork FeatureBv2
  - Commit though integrate manager by patch e-mails
    - git checkout -b topicxxx, work on it and commit, then generate and send the patch.
        - git format-patch -M origin/master, "-M" is used to make git find renames.
        - copy the patch in the generated .patch files and send the mail, or do following
        - git send-email *.patch
            - before send mail, parameters: folder, host, user, pass, port, sslverify, need to be configured with "git config" 

  - Work as integrate manager
    - apply patchs, generated by "git diff" or "diff", with temporary evaluate using branch
        - git checkout -b sc/topicxx master
        - git apply /tmp/patch-topicxx.patch, you also can do "git apply --check /tmp/patch-topicxx.path" beforehand
    - apply patchs generated by "git format-patch"
        - git am 0001-topicxx-msg.patch, you can solve conflictions by following means
            - git am -3 0001-topicxx-msg.patch, which do a three-way merge, or
            - fix conflict manually and do "git add [conflict_files]", "git am --resolved"
        - "-i" is to do "am" at interactive mode, it's especially useful when applying several patchs from a folder
    - determine what introduced
        - git merge-base issuexx master, used to find the common ancestor
        - git diff master...issuexx, use this to find what has changed in both branch from the common ancester.
        
  - some utilities related to release:
    - git provide a means to exchange public keys with gpg.
    - git describe master, can be used to generate a build number
    - git archive master --prefix='project/'| gzip > `git describe master`.tar.gz
        - or, git archive master --prefix='project/' --format=zip
    - git shortlog --no-merges master --not v1.0.1, can be used to generate change log since release v1.0.1
    
12. git tools
  - select revisions:
    - git log master..topicxxx, show revisions in topicxxx that has not merged into master. 
        - git log origin/master..HEAD, use it to check what will be pushed to origin/master in the coming push command
        - git log refA..refB == git log ^refA refB == git log refB --not refA
    - git log master...topicxxx, it will show what have changed in master and topicxxx since their common ancestor.
        - git log --left-right master...topicxxx, it will distinct master and topicxxx comits.

References：
  http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt
